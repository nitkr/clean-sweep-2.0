<?php
/**
 * Clean Sweep - Malware Scanner Orchestrator
 *
 * Main scanner that coordinates different malware detection modules
 * Uses modular architecture for advanced, comprehensive threat detection
 */

// Load all scanner modules
require_once 'signatures.php';
require_once 'core-scanner.php';
require_once 'advanced-analysis.php';
require_once 'persistence.php';

/**
 * Malware Scanner Orchestrator Class
 * Coordinates all malware detection modules for comprehensive scanning
 */
class Clean_Sweep_Malware_Scanner {

    private $core_scanner;
    private $advanced_analysis;
    private $persistence_detector;

    /**
     * Initialize with all scanner modules
     */
    public function __construct() {
        $this->core_scanner = new Clean_Sweep_Core_Malware_Scanner();
        $this->advanced_analysis = new Clean_Sweep_Advanced_Malware_Analysis();
        $this->persistence_detector = new Clean_Sweep_Persistence_Detector();
    }

    /**
     * Add custom signatures
     */
    public function add_signatures($new_signatures) {
        clean_sweep_get_malware_signatures()->add_signatures($new_signatures);
    }

    /**
     * Enhanced database scanning
     */
    public function scan_database($progress_callback = null) {
        return $this->core_scanner->scan_database($progress_callback);
    }

    /**
     * Enhanced file scanning
     */
    public function scan_files($folder_path = null, $progress_callback = null) {
        return $this->core_scanner->scan_files($folder_path, $progress_callback);
    }

    /**
     * Set scan depth override (for advanced/deep scanning)
     */
    public function set_scan_depth($depth) {
        $this->core_scanner->set_scan_depth($depth);
    }

    /**
     * Comprehensive deep scan with advanced modules
     */
    public function scan_deep_additional_tables($progress_callback = null) {
        $results = $this->core_scanner->scan_database($progress_callback);
        $results = $this->advanced_analysis->scan_for_encoding_chains($results, $progress_callback);
        $results = $this->advanced_analysis->scan_for_deconstructed_functions($results, $progress_callback);
        $results = $this->persistence_detector->scan_persistence_check($results, $progress_callback);
        return $results;
    }

    /**
     * Run complete malware scan (database + files)
     */
    public function scan_all($progress_callback = null) {
        return $this->core_scanner->scan_all($progress_callback);
    }

    /**
     * Enhanced deep scan - coordinates all modules
     */
    public function scan_deep($progress_callback = null) {
        set_time_limit(300);
        ini_set('memory_limit', '128M');

        $database_results = $this->core_scanner->scan_database($progress_callback);
        $file_results = $this->core_scanner->scan_files($progress_callback);
        $additional_results = $this->scan_deep_additional_tables($progress_callback);

        return [
            'database' => array_merge_recursive($database_results, $additional_results),
            'files' => $file_results,
            'summary' => [
                'total_scanned' => $database_results['total_scanned'] + $additional_results['total_scanned'],
                'database_threats' => $database_results['threats_found'] + $additional_results['threats_found'],
                'file_threats' => $file_results['file_threats_found'],
                'files_scanned' => $file_results['total_files_scanned'],
                'total_threats' => $database_results['threats_found'] + $additional_results['threats_found'] + $file_results['file_threats_found']
            ]
        ];
    }
}

/**
 * Execute malware scanning for Clean Sweep interface
 */
function clean_sweep_execute_malware_scan() {
    $scan_type = isset($_POST['scan_type']) ? $_POST['scan_type'] : 'all';
    $scan_folder = isset($_POST['scan_folder']) ? $_POST['scan_folder'] : null;
    $level_scan = isset($_POST['level_scan']) ? (bool)$_POST['level_scan'] : false;

    // Set scan depth based on level_scan parameter
    if ($level_scan) {
        clean_sweep_log_message("DEBUG: Level scan parameter received as TRUE");
        clean_sweep_log_message("Setting scan depth to 3 levels (deep scan enabled)");
        $scanner = new Clean_Sweep_Malware_Scanner();
        clean_sweep_log_message("DEBUG: Created Clean_Sweep_Malware_Scanner instance");
        $scanner->set_scan_depth(3); // Enable 3-level deep scanning
        clean_sweep_log_message("DEBUG: Called set_scan_depth(3)");
    } else {
        clean_sweep_log_message("DEBUG: Level scan parameter received as FALSE");
        clean_sweep_log_message("Using default scan depth of 2 levels");
        $scanner = new Clean_Sweep_Malware_Scanner();
        // Default is 2 levels, no override needed
    }

    clean_sweep_log_message("Starting malware scan - Type: {$scan_type}" . ($scan_folder ? ", Folder: {$scan_folder}" : "") . ($level_scan ? ", Deep Scan: Yes" : ""));

    $results = null;
    $progress_file = isset($_POST['progress_file']) ? $_POST['progress_file'] : null;

    $progress_callback = function($current, $total, $message) use ($progress_file) {
        if ($progress_file) {
            $progress_data = [
                'status' => 'scanning',
                'progress' => $total > 0 ? round(($current / $total) * 100) : 0,
                'message' => $message,
                'current' => $current,
                'total' => $total
            ];
            @clean_sweep_write_progress_file($progress_file, $progress_data);
        }
    };

    // ============================================================================
    // INTEGRATE REINFECTION MONITORING
    // ============================================================================

    $integrity_violations = [];

    // Check for reinfection at start of scan
    if (function_exists('clean_sweep_check_for_reinfection')) {
        clean_sweep_log_message("ğŸ” Checking for reinfection before starting malware scan", 'info');
        $initial_violations = clean_sweep_check_for_reinfection();
        if (!empty($initial_violations)) {
            // Merge and deduplicate by file path
            foreach ($initial_violations as $violation) {
                $file_key = $violation['file'] ?? '';
                if (!empty($file_key)) {
                    $integrity_violations[$file_key] = $violation;
                }
            }
            clean_sweep_log_message("ğŸš¨ REINFECTION DETECTED: Core files changed before scan started!", 'error');
        }
    }

    try {
        switch ($scan_type) {
            case 'database':
                $database_results = $scanner->scan_database($progress_callback);

                // Check for reinfection after database scan
                if (function_exists('clean_sweep_check_for_reinfection')) {
                    $scan_violations = clean_sweep_check_for_reinfection();
                    // Merge and deduplicate by file path
                    foreach ($scan_violations as $violation) {
                        $file_key = $violation['file'] ?? '';
                        if (!empty($file_key)) {
                            $integrity_violations[$file_key] = $violation;
                        }
                    }
                }

                $results = [
                    'database' => $database_results,
                    'files' => ['wp_config' => [], 'wp_content' => [], 'total_files_scanned' => 0, 'file_threats_found' => 0],
                    'integrity' => array_values($integrity_violations), // Convert back to indexed array
                    'summary' => [
                        'total_scanned' => $database_results['total_scanned'],
                        'database_threats' => $database_results['threats_found'],
                        'file_threats' => 0,
                        'files_scanned' => 0,
                        'integrity_violations' => count($integrity_violations),
                        'total_threats' => $database_results['threats_found'] + count($integrity_violations)
                    ]
                ];
                break;

            case 'files':
                $file_results = $scanner->scan_files($scan_folder, $progress_callback);

                // Check for reinfection after file scan
                if (function_exists('clean_sweep_check_for_reinfection')) {
                    $scan_violations = clean_sweep_check_for_reinfection();
                    // Merge and deduplicate by file path
                    foreach ($scan_violations as $violation) {
                        $file_key = $violation['file'] ?? '';
                        if (!empty($file_key)) {
                            $integrity_violations[$file_key] = $violation;
                        }
                    }
                }

                $results = [
                    'database' => ['wp_posts' => [], 'wp_options' => [], 'wp_comments' => [], 'total_scanned' => 0, 'threats_found' => 0],
                    'files' => $file_results,
                    'integrity' => array_values($integrity_violations), // Convert back to indexed array
                    'summary' => [
                        'total_scanned' => 0,
                        'database_threats' => 0,
                        'file_threats' => $file_results['file_threats_found'],
                        'files_scanned' => $file_results['total_files_scanned'],
                        'integrity_violations' => count($integrity_violations),
                        'total_threats' => $file_results['file_threats_found'] + count($integrity_violations)
                    ]
                ];
                break;

            case 'deep':
                set_time_limit(300);
                ini_set('memory_limit', '128M');

                // Create enhanced progress callback that includes reinfection monitoring
                $enhanced_progress_callback = function($current, $total, $message) use ($progress_callback, &$integrity_violations) {
                    // Call original progress callback
                    if ($progress_callback) {
                        $progress_callback($current, $total, $message);
                    }

                    // Check for reinfection at 25%, 50%, 75% progress milestones
                    if ($total > 0) {
                        $progress_percent = round(($current / $total) * 100);
                        if (in_array($progress_percent, [25, 50, 75])) {
                            if (function_exists('clean_sweep_check_for_reinfection')) {
                                clean_sweep_log_message("ğŸ” Periodic reinfection check at {$progress_percent}% progress", 'info');
                                $periodic_violations = clean_sweep_check_for_reinfection();
                                // Merge and deduplicate by file path
                                foreach ($periodic_violations as $violation) {
                                    $file_key = $violation['file'] ?? '';
                                    if (!empty($file_key)) {
                                        $integrity_violations[$file_key] = $violation;
                                    }
                                }
                            }
                        }
                    }
                };

                $database_results = $scanner->scan_database($enhanced_progress_callback);
                $additional_results = $scanner->scan_deep_additional_tables($enhanced_progress_callback);
                $file_results = $scanner->scan_files(null, $enhanced_progress_callback);  // Fixed parameter order

                // Final reinfection check after deep scan
                if (function_exists('clean_sweep_check_for_reinfection')) {
                    $final_violations = clean_sweep_check_for_reinfection();
                    // Merge and deduplicate by file path
                    foreach ($final_violations as $violation) {
                        $file_key = $violation['file'] ?? '';
                        if (!empty($file_key)) {
                            $integrity_violations[$file_key] = $violation;
                        }
                    }
                }

                $results = [
                    'database' => array_merge_recursive($database_results, $additional_results),
                    'files' => $file_results,
                    'integrity' => array_values($integrity_violations), // Convert back to indexed array
                    'summary' => [
                        'total_scanned' => $database_results['total_scanned'] + $additional_results['total_scanned'],
                        'database_threats' => $database_results['threats_found'] + $additional_results['threats_found'],
                        'file_threats' => $file_results['file_threats_found'],
                        'files_scanned' => $file_results['total_files_scanned'],
                        'integrity_violations' => count($integrity_violations),
                        'total_threats' => $database_results['threats_found'] + $additional_results['threats_found'] + $file_results['file_threats_found'] + count($integrity_violations)
                    ]
                ];
                break;

            case 'all':
            default:
                // Enhanced progress callback for 'all' scans
                $enhanced_progress_callback = function($current, $total, $message) use ($progress_callback, &$integrity_violations) {
                    // Call original progress callback
                    if ($progress_callback) {
                        $progress_callback($current, $total, $message);
                    }

                    // Periodic reinfection checks during long scans
                    static $last_check_percent = 0;
                    if ($total > 0) {
                        $progress_percent = round(($current / $total) * 100);
                        // Check every 20% progress during file scanning (most time-consuming part)
                        if ($progress_percent >= $last_check_percent + 20 && strpos($message, 'files') !== false) {
                            if (function_exists('clean_sweep_check_for_reinfection')) {
                                clean_sweep_log_message("ğŸ” Periodic reinfection check at {$progress_percent}% progress", 'info');
                                $periodic_violations = clean_sweep_check_for_reinfection();
                                $integrity_violations = array_merge($integrity_violations, $periodic_violations);
                                $last_check_percent = $progress_percent;
                            }
                        }
                    }
                };

                $results = $scanner->scan_all($enhanced_progress_callback);

                // Final reinfection check
                if (function_exists('clean_sweep_check_for_reinfection')) {
                    $final_violations = clean_sweep_check_for_reinfection();
                    $integrity_violations = array_merge($integrity_violations, $final_violations);
                }

                // Add integrity results to the scan results
                $results['integrity'] = $integrity_violations;
                $results['summary']['integrity_violations'] = count($integrity_violations);
                $results['summary']['total_threats'] += count($integrity_violations);

                break;
        }

        if ($progress_file) {
            $completion_data = [
                'status' => 'complete',
                'progress' => 100,
                'message' => 'Malware scan completed!',
                'results' => $results
            ];
            @clean_sweep_write_progress_file($progress_file, $completion_data);
        }

        return $results;

    } catch (Exception $e) {
        clean_sweep_log_message("Malware scan error: " . $e->getMessage(), 'error');

        if ($progress_file) {
            $error_data = [
                'status' => 'error',
                'message' => 'Scan failed: ' . $e->getMessage(),
                'error' => $e->getMessage()
            ];
            @clean_sweep_write_progress_file($progress_file, $error_data);
        }

        return ['error' => $e->getMessage(), 'status' => 'failed'];
    }
}

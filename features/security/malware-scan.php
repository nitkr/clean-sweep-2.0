<?php
/**
 * Clean Sweep - Malware Scanner Orchestrator
 *
 * Main scanner that coordinates different malware detection modules
 * Uses modular architecture for advanced, comprehensive threat detection
 */

// Load all scanner modules
require_once 'signatures.php';
require_once 'core-scanner.php';
require_once 'advanced-analysis.php';
require_once 'persistence.php';

/**
 * Malware Scanner Orchestrator Class
 * Coordinates all malware detection modules for comprehensive scanning
 */
class Clean_Sweep_Malware_Scanner {

    private $core_scanner;
    private $advanced_analysis;
    private $persistence_detector;

    /**
     * Initialize with all scanner modules
     */
    public function __construct() {
        $this->core_scanner = new Clean_Sweep_Core_Malware_Scanner();
        $this->advanced_analysis = new Clean_Sweep_Advanced_Malware_Analysis();
        $this->persistence_detector = new Clean_Sweep_Persistence_Detector();
    }

    /**
     * Add custom signatures
     */
    public function add_signatures($new_signatures) {
        clean_sweep_get_malware_signatures()->add_signatures($new_signatures);
    }

    /**
     * Enhanced database scanning
     */
    public function scan_database($progress_callback = null) {
        return $this->core_scanner->scan_database($progress_callback);
    }

    /**
     * Enhanced file scanning
     */
    public function scan_files($folder_path = null, $progress_callback = null) {
        return $this->core_scanner->scan_files($folder_path, $progress_callback);
    }

    /**
     * Set scan depth override (for advanced/deep scanning)
     */
    public function set_scan_depth($depth) {
        $this->core_scanner->set_scan_depth($depth);
    }

    /**
     * Comprehensive deep scan with advanced modules
     */
    public function scan_deep_additional_tables($progress_callback = null) {
        $results = $this->core_scanner->scan_database($progress_callback);
        $results = $this->advanced_analysis->scan_for_encoding_chains($results, $progress_callback);
        $results = $this->advanced_analysis->scan_for_deconstructed_functions($results, $progress_callback);
        $results = $this->persistence_detector->scan_persistence_check($results, $progress_callback);
        return $results;
    }

    /**
     * Run complete malware scan (database + files)
     */
    public function scan_all($progress_callback = null) {
        return $this->core_scanner->scan_all($progress_callback);
    }

    /**
     * Enhanced deep scan - coordinates all modules
     */
    public function scan_deep($progress_callback = null) {
        set_time_limit(300);
        ini_set('memory_limit', '128M');

        $database_results = $this->core_scanner->scan_database($progress_callback);
        $file_results = $this->core_scanner->scan_files($progress_callback);
        $additional_results = $this->scan_deep_additional_tables($progress_callback);

        return [
            'database' => array_merge_recursive($database_results, $additional_results),
            'files' => $file_results,
            'summary' => [
                'total_scanned' => $database_results['total_scanned'] + $additional_results['total_scanned'],
                'database_threats' => $database_results['threats_found'] + $additional_results['threats_found'],
                'file_threats' => $file_results['file_threats_found'],
                'files_scanned' => $file_results['total_files_scanned'],
                'total_threats' => $database_results['threats_found'] + $additional_results['threats_found'] + $file_results['file_threats_found']
            ]
        ];
    }
}

/**
 * Helper function to merge integrity violations without duplicates
 * Defined globally to be accessible from all scopes
 */
if (!function_exists('clean_sweep_merge_integrity_violations')) {
    function clean_sweep_merge_integrity_violations($existing, $new_violations) {
        if (!empty($new_violations)) {
            foreach ($new_violations as $violation) {
                $file_key = $violation['file'] ?? '';
                if (!empty($file_key)) {
                    $existing[$file_key] = $violation; // Deduplicates by file path
                }
            }
        }
        return $existing;
    }
}

/**
 * Execute malware scanning for Clean Sweep interface
 */
function clean_sweep_execute_malware_scan() {
    $scan_type = isset($_POST['scan_type']) ? $_POST['scan_type'] : 'all';
    $scan_folder = isset($_POST['scan_folder']) ? $_POST['scan_folder'] : null;
    $level_scan = isset($_POST['level_scan']) ? (bool)$_POST['level_scan'] : false;

    // Set scan depth based on level_scan parameter
    if ($level_scan) {
        $scanner = new Clean_Sweep_Malware_Scanner();
        $scanner->set_scan_depth(3);
    } else {
        $scanner = new Clean_Sweep_Malware_Scanner();
        // Default is 2 levels, no override needed
    }

    clean_sweep_log_message("Starting malware scan - Type: {$scan_type}" . ($scan_folder ? ", Folder: {$scan_folder}" : "") . ($level_scan ? ", Deep Scan: Yes" : ""));

    $results = null;
    $progress_file = isset($_POST['progress_file']) ? $_POST['progress_file'] : null;

    $progress_callback = function($current, $total, $message) use ($progress_file) {
        if ($progress_file) {
            $progress_data = [
                'status' => 'scanning',
                'progress' => $total > 0 ? round(($current / $total) * 100) : 0,
                'message' => $message,
                'current' => $current,
                'total' => $total
            ];
            @clean_sweep_write_progress_file($progress_file, $progress_data);
        }
    };

    // ============================================================================
    // INTEGRITY MONITORING MOVED TO ASYNC
    // ============================================================================

    // Integrity checks now run asynchronously after scan completion to prevent
    // resource conflicts and 404 polling errors with large baselines (32MB+)
    $integrity_violations = [];

    try {
        switch ($scan_type) {
            case 'database':
                $database_results = $scanner->scan_database($progress_callback);

                $results = [
                    'database' => $database_results,
                    'files' => ['wp_config' => [], 'wp_content' => [], 'total_files_scanned' => 0, 'file_threats_found' => 0],
                    'integrity' => [], // Integrity checks now run asynchronously
                    'summary' => [
                        'total_scanned' => $database_results['total_scanned'],
                        'database_threats' => $database_results['threats_found'],
                        'file_threats' => 0,
                        'files_scanned' => 0,
                        'integrity_violations' => 0,
                        'total_threats' => $database_results['threats_found']
                    ]
                ];
                break;

            case 'files':
                $file_results = $scanner->scan_files($scan_folder, $progress_callback);

                $results = [
                    'database' => ['wp_posts' => [], 'wp_options' => [], 'wp_comments' => [], 'total_scanned' => 0, 'threats_found' => 0],
                    'files' => $file_results,
                    'integrity' => [], // Integrity checks now run asynchronously
                    'summary' => [
                        'total_scanned' => 0,
                        'database_threats' => 0,
                        'file_threats' => $file_results['file_threats_found'],
                        'files_scanned' => $file_results['total_files_scanned'],
                        'integrity_violations' => 0,
                        'total_threats' => $file_results['file_threats_found']
                    ]
                ];
                break;

            case 'deep':
                set_time_limit(300);
                ini_set('memory_limit', '128M');

                $database_results = $scanner->scan_database($progress_callback);
                $additional_results = $scanner->scan_deep_additional_tables($progress_callback);
                $file_results = $scanner->scan_files(null, $progress_callback);

                $results = [
                    'database' => array_merge_recursive($database_results, $additional_results),
                    'files' => $file_results,
                    'integrity' => [], // Integrity checks now run asynchronously
                    'summary' => [
                        'total_scanned' => $database_results['total_scanned'] + $additional_results['total_scanned'],
                        'database_threats' => $database_results['threats_found'] + $additional_results['threats_found'],
                        'file_threats' => $file_results['file_threats_found'],
                        'files_scanned' => $file_results['total_files_scanned'],
                        'integrity_violations' => 0,
                        'total_threats' => $database_results['threats_found'] + $additional_results['threats_found'] + $file_results['file_threats_found']
                    ]
                ];
                break;

            case 'all':
            default:
                $results = $scanner->scan_all($progress_callback);

                // Integrity checks now run asynchronously after scan completion
                $results['integrity'] = [];
                $results['summary']['integrity_violations'] = 0;
                // total_threats remains as is (malware threats only)

                break;
        }

        if ($progress_file) {
            $completion_data = [
                'status' => 'complete',
                'progress' => 100,
                'message' => 'Malware scan completed!',
                'results' => $results
            ];
            @clean_sweep_write_progress_file($progress_file, $completion_data);
        }

        return $results;

    } catch (Exception $e) {
        clean_sweep_log_message("Malware scan error: " . $e->getMessage(), 'error');

        if ($progress_file) {
            $error_data = [
                'status' => 'error',
                'message' => 'Scan failed: ' . $e->getMessage(),
                'error' => $e->getMessage()
            ];
            @clean_sweep_write_progress_file($progress_file, $error_data);
        }

        return ['error' => $e->getMessage(), 'status' => 'failed'];
    }
}
